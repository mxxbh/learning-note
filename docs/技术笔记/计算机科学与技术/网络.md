# 网络

- 使用命令 `netsh wlan show profiles '<wifi 名称>' key=clear` 查看 wifi 详细信息

## 网络结构模型

### OSI 七层模型

- 开放式系统互联 (Open System Interconnection, OSI)，意为开放式系统互联，把网络通信的工作分为 7 层，分别是物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。

应用层：

- 应用层是最靠近用户的 OSI 层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。
- 应用层是网络应用协议以及它们的应用层协议存留的地方。
- 应用层协议分布在多个端系统上，一个端系统中的应用程序使用协议与另一个端系统中的应用程序协议交换信息分组，即报文。
- 运行在应用层的协议有：HTTP、SMTP（邮件报文传输协议）、POP3、FTP（文件传输协议）、DNS 等。

表示层：

- 这一层的主要功能是定义数据格式及加密。

会话层：

- 定义如何开始、控制和结束一个会话，包括对多个双向会话的控制和管理。

传输层：（运输层）

- 作用是在应用程序端点之间传输应用层报文。
- 运行的协议有：TCP，UDP。

网络层：

- 负责将数据报的网络层分组从一台主机移动到另一台主机。
- 运行的协议有：IP 协议（定义了数据报在各个字段以及端系统和路由器如何作用域这些字段）。

数据链路层：

- 定义在单个链路上如何传输数据。

物理层：

- 将报文中的一个一个比特的数据从一个节点移到下一个节点。

### TCP/IP 四层协议

- TCP/IP 协议族是一个四层协议系统，自底而上分别是数据链路层、网络层、传输层和应用层。
- 每一层完成不同的功能，且通过若干协议来实现，上层协议使用下层协议提供的服务。
- 上层屏蔽下层细节，只使用其提供的服务。
- 高内聚低耦合，每一层专注于其功能，各层之间的关系依赖不大。
- 数据包在每层有不同的格式，从上到下依次叫段、数据报、帧、数据。
- 从应用层通过协议栈向下传递，每经过一层加上对应层协议的报头，最后封装成帧发送到传输介质上，到达路由器或者目的主机剥掉头部，交付给上层需要者。这一过程称为封装，传输，分离，分用。

应用层：

- 应用层负责处理应用程序的逻辑。
- 应用层在用户空间实现，因为它负责处理众多逻辑，比如文件传输、名称查询和网络管理等。如果在内核中实现，会使内核变得非常庞大。
- 也有少数服务器程序是在内核中实现的，这样就无须在用户空间和内核空间来回切换（如数据的复制），提高了工作效率。但实现复杂，不够灵活，不便于移植。
- 应用层协议或程序可能跳过传输层直接使用网络层提供的服务，比如 ping 程序和 OSPF 协议。
- 应用层协议或程序通常既可以使用 TCP 服务，又可以使用 UDP 服务，比如 DNS 协议。
- 可以通过 /etc/services 文件查看所有知名的应用层协议，以及它们都能使用哪些传输层服务。

传输层：

- 传输层为两台主机上的应用程序提供端到端（end to end）的通信。
- 传输层只关心通信的起始端和目的端，而不在乎数据包的中转过程。
- 一般在内核空间中实现。
- 传输层为应用程序封装了一条端到端的逻辑通信链路，它负责数据的收发、链路的超时重连等。

网络层：（互联层）

- 网络层实现数据包的选路和转发。
- 一般在内核空间中实现。
- 网络层封装了网络连接的细节。
- 通信的两台主机一般不是直接相连的，而是通过多个中间节点（路由器）连接的。
- 网络层的任务就是选择这些中间节点，以确定两台主机之间的通信路径。
- 网络层对上层协议隐藏了网络拓扑连接的细节，使得在传输层和网络应用程序看来，通信的双方是直接相连的。

数据链路层：（主机—网络层）

- 数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理媒介（比如以太网、令牌环等）上的传输。
- 一般在内核空间中实现。
- 数据链路层（驱动程序）封装了物理网络的电气细节。

### OSI 七层和 TCP/IP 四层的关系

- OSI 引进了服务、接口、协议、分层的概念，TCP/IP 借鉴了 OSI 的这些概念建立 TCP/IP 模型。
- OSI 先有模型，后有协议，先有标准，后进行实践；而 TCP/IP 则相反，先有协议和应用，再提出了模型，且是参照 OSI 模型。
- OSI 是一种理论下的模型，而 TCP/IP 已经被广泛应用，称为网络互联实施上的标准。

对应：

1. TCP/IP 应用层与 OSI 应用层相对应。
2. TCP/IP 传输层与 OSI 传输层相对应。
3. TCP/IP 互联层与 OSI 网络层相对应。
4. TCP/IP 主机—网络层与 OSI 数据链路层及物理层相对应。
5. TCP/IP 参考模型中，没有与 OSI 表示层、会话层对应的协议。

### 相关服务

PING：（Packet Internet Groper，互联网包探索器）

- 是用于测试网络连接量的程序。
- Ping 发送一个 ICMP 回声请求消息给目的地，并报告是否收到所希望的 ICMPecho（ICMP 回声应答）。
- 是用来检查网络是否通畅或者网络连接速度的命令。
- ping 命令是第一个必须掌握的 DOS 命令。

Traceroute：

- 通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。
- 一条路径上的每个设备 Traceroute 要测三次。
- 输出结果中包括每次测试的时间（ms）和设备的名称（如果有）及其 IP 地址。
- 通过 Traceroute 可以知道信息从个人计算机到互联网另一端的主机是走什么路径。
- 每次数据包由某一同样的出发点（source）到达某一同样的目的地（destination）走的路径可能会不一样。
- 通过 Traceroute 是可以显示源机器与目标机器之间的路由数量，以及各路由之间的 RTT。

WAN：（Wide Area Network，广域网）

- 通常使用众多分级的路由器来连接分散的主机或 LAN（Local Area Network，局域网）。

telnet 协议：

- 是 TCP/IP 协议簇中的一员，是互联网远程登录服务的标准协议和主要方式。
- 主要用于远程登录，为用户提供了在本地计算机上完成远程主机工作的能力。
- 在终端使用者的计算机上使用 telnet 程序，用它连接到服务器。
- 终端使用者可以在 telnet 程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样，在本地就能控制服务器。

OSPF 协议：（Open Shortest Path First，开放最短路径优先）

- 是一种动态路由更新协议，用于路由器之间的通信，以告知对方各自的路由信息。

DNS 协议：（Domain Name Service，域名服务）

- 提供机器域名到 IP 地址的单向转换。
- 本地机器一般在上网后会有一个对应的 DNS 服务器，要么手工配置的，要么连接的网络自动分配。
- 浏览器发现要对某个 url 发送请求时，便会将这个 url 交给配置好的 DNS 服务器，查看有没有对应 url 里那个域名的 ip 信息。
- 如果本级服务器没有查到，这个 DNS 会将该 url 传给它的上层 DNS。
- 整个 DNS 可以看做是一个树状结构，该请求将一直发送到根域名服务器直到得到结果。
- DNS 协议大多数运行在 UDP 协议之上，端口号为 53。
- 默认缓存时间是 86400s，也就是一天。

UDP 协议：（User Datagram Protocol，用户数据报协议）

- 与 TCP 协议相反，为应用层提供不可靠、无连接和基于数据报的服务。
- “不可靠”意味着 UDP 协议无法保证数据从发送端正确地传送到目的端。
- 如果数据在中途丢失，或者目的端通过数据校验发现数据错误而将其丢弃，UDP 协议只是单地通知应用程序发送失败。
- 因此，使用 UDP 协议的应用程序通常要自己处理数据确认、超时重传等逻辑。
- UDP 协议是无连接的，即通信双方不保持一个长久的联系，因此应用程序每次发送数据都要明确指定接收端的地址（IP 地址等信息）。
- 基于数据报的服务，相对基于流的服务而言。
- 每个 UDP 数据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一次性读出，否则数据将被截断。

IP 协议：（Internet Protocol，因特网协议）

- 网络层最核心的协议。
- IP 协议根据数据包的目的 IP 地址来决定如何投递它。
- 如果数据包不能直接发送给目标主机，那么就为它寻找一个合适的下一跳（next hop）路由器，并将数据包交付给该路由器来转发。
- 多次重复这一过程，数据包最终到达目标主机。
- 或者由于发送失败而被丢弃。
- IP 协议使用逐跳（hop by hop）的方式确定通信路径。

ICMP 协议：（Internet Control Message Protocol，因特网控制报文协议）

- 是 IP 协议的重要补充，主要用于检测网络连接。

ARP 协议：（Address Resolve Protocol，地址解析协议）

- 将目标机器的 IP 地址转化成其物理地址（通常是 MAC 地址）。

RARP 协议：（ReverseAddress Resolve Protocol，逆地址解析协议）

- 将目标机器的物理地址（通常是 MAC 地址）转化成其 IP 地址。
- RARP 协议仅用于网络上的某些无盘工作站。
- 因为缺乏存储设备，无盘工作站无法记住自己的 IP 地址，但可以利用网卡上的物理地址来向网络管理者查询自身的 IP 地址。
- 运行 RARP 服务的网络管理者通常存有该网络上所有机器的物理地址到 IP 地址的映射。

## 网络协议

### 传输层协议

TCP 和 UDP：

- TCP 中植入了各种安全保障功能，在实际执行的过程中会占用大量的系统开销，使速度受到严重的影响。
- UDP 排除了信息可靠传递机制，将安全和排序等功能移交给上层应用来完成，降低了执行时间。

#### TCP 协议

TCP（Transmission Control Protocol，传输控制协议）

- 可以提供可靠的、面向连接的和基于流（stream）网络数据传递服务。
- 确保 IP 数据报的成功传递。
- 对程序发送的大块数据进行分段和重组。
- 确保正确排序及按顺序传递分段的数据。
- 通过计算校验和，进行传输数据的完整性检查。
- 根据数据是否接收成功发送肯定消息。通过使用选择性确认，也对没有收到的数据发送否定确认。
- 为必须使用可靠的、基于会话的数据传输程序，如客户端/服务器数据库和电子邮件程序，提供首选传输方法。

头部结构：

- TCP 数据包头部总长最小为 20 字节。

| 字段          | 作用                                                                     |
| ------------- | ------------------------------------------------------------------------ |
| 源端口        | 指定了发送端的端口                                                       |
| 目的端口      | 指定了接受端的端口号                                                     |
| 序列号（seq） | 指明了段在即将传输的段序列中的位置                                       |
| 确认号（ack） | 规定成功收到段的序列号，确认序号包含发送确认的一端所期望收到的下一个序号 |
| TCP 偏移量    | 指定了段头的长度。段头的长度取决于段头选项字段中设置的选项               |
| 保留          | 指定了一个保留字段，以备将来使用                                         |
| 标志          | 标识功能                                                                 |
| 窗口          | 指定关于发送端能传输的下一段大小的指令                                   |
| 校验和        | 校验和包含 TCP 段头和数据部分，用来校验段头和数据部分的可靠性            |
| 紧急          | 指明段中包含紧急信息，只有当 URG 标志置 1 时紧急指针才有效               |
| 选项          | 指定了公认的段大小，时间戳，选项字段的末端，以及指定了选项字段的边界选项 |

| 标志位 | 功能                         |
| ------ | ---------------------------- |
| SYN    | 表示同步                     |
| ACK    | 表示确认                     |
| PSH    | 表示尽快地将数据送往接收进程 |
| RST    | 表示复位连接                 |
| URG    | 表示紧急指针                 |
| FIN    | 表示发送方完成数据发送       |

各种状态：

| 状态        | 作用                                                                                                              |
| ----------- | ----------------------------------------------------------------------------------------------------------------- |
| CLOSED      | 表示初始状态                                                                                                      |
| LISTEN      | 表示服务器端的某个 SOCKET 处于监听状态，可以接受连接                                                              |
| SYN_RCVD    | 表示接受到 SYN 报文，该状态是服务器端 SOCKET 在建立 TCP 连接时的三次握手过程中的中间状态                          |
| SYN_SENT    | 表示客户端已发送 SYN 报文。与 SYN_RCVD 相呼应                                                                     |
| ESTABLISHED | 表示连接已经建立                                                                                                  |
| FIN_WAIT_1  | 当 SOCKET 在 ESTABLISHED 状态时，想主动关闭连接，向对方发送了 FIN 报文，此时 SOCKET 进入 FIN_WAIT_1 状态          |
| FIN_WAIT_2  | 表示半连接，即有一方要求 close 连接，但还告诉对方，还有数据需要传送，稍后再关闭连接                               |
| TIME_WAIT   | 表示收到了对方的 FIN 报文，并发送出了 ACK 报文，就等 2MSL 后即可回到 CLOSED 可用状态了                            |
| CLOSING     | 比较罕见的例外状态。CLOSING 状态表示发送 FIN 报文后，并没有收到对方的 ACK 报文，反而却也收到了对方的 FIN 报文     |
| CLOSE_WAIT  | 表示在等待关闭。当对方 close 一个 SOCKET 后发送 FIN 报文，系统会回应一个 ACK 报文给对方，然后进入 CLOSE_WAIT 状态 |
| LAST_ACK    | 是被动关闭一方在发送 FIN 报文后，等待对方的 ACK 报文。当收到 ACK 报文后，进入到 CLOSED 状态                       |

工作过程：

- TCP 连接关闭：
  - 发送方主机和目的主机建立 TCP 连接并完成数据传输后，会发送一个将结束标记置 1 的数据包。
  - 这个数据包用以关闭这个 TCP 连接，并同时释放该连接占用的缓冲区空间。
- TCP 重置：
  - TCP 允许在传输的过程中突然中断连接。
- TCP 数据排序和确认：
  - 在传输的过程中使用序列号和确认号来跟踪数据的接收情况。
- TCP 重传：
  - 传输过程中，如果在重传超时时间内没有收到接收方主机对某数据包的确认回复，发送方主机就认为此数据包丢失。
  - 然后发送方会再次发送这个数据包给接收方。
- TCP 延迟确认：
  - TCP 并不总是在接收到数据后对其进行确认，它允许主机在接收数据的同时发送自己的确认信息给对方。
- TCP 数据保护（校验和）：
  - TCP 是可靠传输的协议，它提供校验和计算来实现数据在传输过程中的完整性。

##### TCP 三次握手

第一次握手：

1. Client 将标志位 SYN 置为 1，随机产生一个值 seq=J，并将该数据包发送给 Server。
2. Client 进入 SYN_SENT 状态，等待 Server 确认。

第二次握手：

1. Server 收到数据包后由标志位 SYN=1 知道 Client 请求建立连接。
2. Server 将标志位 SYN 和 ACK 都置为 1，ack=J+1，随机产生一个值 seq=K，并将该数据包发送给 Client 以确认连接请求。
3. Server 进入 SYN_RCVD 状态。

第三次握手：

1. Client 收到确认后，检查 ack 是否为 J+1，ACK 是否为 1。
2. 如果正确则将标志位 ACK 置为 1，ack=K+1，并将该数据包发送给 Server。
3. Server 检查 ack 是否为 K+1，ACK 是否为 1，如果正确则连接建立成功。
4. Client 和 Server 进入 ESTABLISHED 状态，完成三次握手，随后 Client 与 Server 之间可以开始传输数据。

三次握手的原因：

1.  例如，客户端发了一个请求建立连接的包，
2.  由于网络原因迟迟没有抵达服务器，客户端只得再发一次请求，这次成功抵达并完成了数据传输。
3.  过了一段时间，第一次延迟的请求也到了服务器，服务器并不知道这是无效请求，依旧正常响应，
4.  如果是二次握手，那么这个时候就会建立一条无效的连接，
5.  而如果是三次握手，那么客户端就能够丢弃这条连接，避免了无谓的网络开销。

##### TCP 四次挥手

1. 由于 TCP 连接时全双工的，因此，每个方向都必须要单独进行关闭，
2. 这一原则是当一方完成数据发送任务后，发送一个 FIN 来终止这一方向的连接，
3. 收到一个 FIN 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但仍然能够发送数据，直到也发送 FIN。
4. 首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

第一次挥手：

1. Client 发送一个 FIN=1，seq=u，用来关闭 Client 到 Server 的数据传送。
2. Client 进入 FIN_WAIT_1 状态。

第二次挥手：

1. Server 收到 FIN 后，发送一个 ACK=1，seq=v，ack=u+1 给 Client。
2. Server 进入 CLOSE_WAIT 状态。

第三次挥手：

1. Server 发送一个 FIN=1，seq=w，用来关闭 Server 到 Client 的数据传送。
2. Server 进入 LAST_ACK 状态。

第四次挥手：

1.  Client 收到 FIN 后，Client 进入 TIME_WAIT 状态。
2.  接着发送一个 ACK=1，seq=u+1，ack=w+1 给 Server，确认序号为收到序号 +1。
3.  Server 进入 CLOSED 状态，完成四次挥手。

#### UDP 协议

UDP 协议：（User Datagram Protocol，用户数据报协议）

1. 提供无连接的网络服务，该服务对消息中传输的数据提供不可靠的、最大努力传送。
2. 它不保证数据报的到达，也不保证所传送数据包的顺序是否正确。

包结构：

- 源、目的端口：
  - 作用与 TCP 数据段中的端口号字段相同，用来标识源端和目标端的应用进程。
- 用户数据包的长度：
  - 标明 UDP 头部和 UDP 数据的总长度字节。
- 校验和：
  - 用来对 UDP 头部和 UDP 数据进行校验。
  - UDP 中此字段是可选项，而 TCP 数据段中的校验和字段是必须有的。

### 网络层协议

#### IP 协议

- IP 协议是将多个包交换网络连接起来，在源地址和目的地址之间数据包，同时还能对数据进行重新组装，以适应不同网络对包大小的要求。
- IP 不提供可靠的传输服务，
  - 不提供端到端的或（路由）结点到（路由）结点的确认。
  - 对数据没有差错控制，只使用报头的校验码，它不提供重发和流量控制。
  - 如果出错可以通过 ICMP 报告，ICMP 在 IP 模块中实现。

功能：

1. 寻址与路由：

- 用 IP 地址来标识 Internet 的主机：
  - 在每个 IP 数据报中,都会携带源 IP 地址和目标 IP 地址来标识该 IP 数据报的源和目的主机。
  - IP 数据报在传输过程中，每个中间节点（ IP 网关）还需要为其选择从源主机到目的主机的合适的转发路径，即路由。
  - IP 协议可以根据路由选择协议提供的路由信息对 IP 数据报进行转发,直至抵达目的主机。
- IP 地址和 MAC 地址的匹配，ARP 协议。
  - 数据链路层使用 MAC 地址来发送数据帧，因此在实际发送 IP 报文时,还需要进行 IP 地址和 MAC 地址的匹配。
  - 由 TCP/IP 协议簇中的 ARP (地址解析协议)完成.

2. 分段与重组：

- IP 数据报通过不同类型的通信网络发送，IP 数据报的大小会受到这些网络所规定的最大传输单元 MTU 的限制。

### 应用层协议

#### HTTP 协议

HTTP 协议（Hyper Text Transfer Protocol，超文本传输协议）

- 用于从万维网（World Wide Web，WWW）服务器传输超文本到本地浏览器的传送协议。
- 是一个基于 TCP/IP 通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

主要特点：

1. 简单快速：

- 客户向服务器请求服务时，只需传送请求方法和路径。
- 请求方法常用的有 GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。
- 由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。

2. 灵活：

- HTTP 允许传输任意类型的数据对象。
- 正在传输的类型由 Content-Type 加以标记。

3. 无连接：

- 无连接的含义是限制每次连接只处理一个请求。
- 服务器处理完客户的请求，并收到客户的应答后，即断开连接。
- 采用这种方式可以节省传输时间。

4. 无状态：

- HTTP 协议是无状态协议。
- 无状态是指协议对于事务处理没有记忆能力。
- 缺少状态意味着如果后续处理需要前面的信息，则必须重传。
- 这样可能导致每次连接传送的数据量增大，但在服务器不需要先前信息时它的应答就较快。

工作原理：

1. HTTP 协议定义 Web 客户端如何从 Web 服务器请求 Web 页面，以及服务器如何把 Web 页面传送给客户端。
2. HTTP 协议采用了请求/响应模型。
3. 客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。
4. 服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。

HTTP 请求/响应的步骤：

1. 客户端连接到 Web 服务器。
2. 发送 HTTP 请求。
   - 通过 TCP 套接字，客户端向 Web 服务器发送一个文本的请求报文。
   - 一个请求报文由请求行、请求头部、空行和请求数据四部分组成。
3. 服务器接受请求并返回 HTTP 响应。
   - Web 服务器解析请求，定位请求资源。
   - 服务器将资源复本写到 TCP 套接字，由客户端读取。
   - 一个响应由状态行、响应头部、空行和响应数据四部分组成。
4. 释放连接 TCP 连接。
   - 若 connection 模式为 close，则服务器主动关闭 TCP 连接，客户端被动关闭连接，释放 TCP 连接。
   - 若 connection 模式为 keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求。
5. 客户端浏览器解析 HTML 内容。
   - 客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。
   - 然后解析每一个响应头，响应头告知以下为若干字节的 HTML 文档和文档的字符集。
   - 客户端浏览器读取响应数据 HTML，根据 HTML 的语法对其进行格式化，并在浏览器窗口中显示。

HTTP/1.1 的不足：

1. 在传输中会出现队首阻塞问题。
2. 响应不分轻重缓急，只会按先来后到的顺序执行。
3. 并行通信需要建立多个 TCP 连接。
4. 服务器不能主动推送客户端想要的资源，只能被动地等待客户端发起请求。
5. 由于 HTTP 是无状态的，所以每次请求和响应都会携带大量冗余信息。

HTTP 不安全的原因：

1. 数据以明文传递，有被窃听的风险。
2. 接收到的报文无法证明是发送时的报文，不能保障完整性，因此报文有被篡改的风险。
3. 不验证通信两端的身份，请求或响应有被伪造的风险。

##### HTTP 请求方式

GET 请求：

- 指定的页面信息，并返回实体主体。

HEAD 请求：

- 类似于 get 请求，只不过返回的响应中没有具体的内容，用于获取报头。

POST 请求：

- 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。
- 数据被包含在请求体中。
- POST 请求可能会导致新的资源的建立和/或已有资源的修改。

PUT 请求：

- 从客户端向服务器传送的数据取代指定的文档的内容。

DELETE 请求：

- 服务器删除指定的页面。

CONNECT 请求：

- HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。

OPTIONS 请求：

- 允许客户端查看服务器的性能。

TRACE 请求：

- 回显服务器收到的请求，主要用于测试或诊断。

##### HTTP 状态码

1. 状态代码有三位数字组成，第一个数字定义了响应的类别。

| 类别 | 含义                                     |
| ---- | ---------------------------------------- |
| 1xx  | 指示信息, 表示请求已接收，继续处理       |
| 2xx  | 成功, 表示请求已被成功接收、理解、接受   |
| 3xx  | 重定向, 要完成请求必须进行更进一步的操作 |
| 4xx  | 客户端错误, 请求有语法错误或请求无法实现 |
| 5xx  | 服务器端错误, 服务器未能实现合法的请求   |

常见状态码：

| 状态码                    | 含义                                                                                          |
| ------------------------- | --------------------------------------------------------------------------------------------- |
| 200 OK                    | 客户端请求成功                                                                                |
| 301 永久移动              | 请求的网页已永久移动到新位置。 服务器返回此响应（GET 或 HEAD 请求），会自动将请求者转到新位置 |
| 302 临时移动              | 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求                |
| 400 Bad Request           | 客户端请求有语法错误，不能被服务器所理解                                                      |
| 401 Unauthorized          | 请求未经授权，这个状态代码必须和 WWW-Authenticate 报头域一起使用                              |
| 403 Forbidden             | 服务器收到请求，但是拒绝提供服务                                                              |
| 404 Not Found             | 请求资源不存在，eg：输入了错误的 URL                                                          |
| 500 Internal Server Error | 服务器发生不可预期的错误                                                                      |
| 503 Server Unavailable    | 服务器当前不能处理客户端的请求，只是暂时状态，一段时间后可能恢复正常                          |

##### HTTP 请求报文

1. 请求报文由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。

示例：一个 get 请求

```
GET /562f25980001b1b106000338.jpg HTTP/1.1
Host img.mukewang.com
User-Agent Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko)  Chrome/51.0.2704.106 Safari/537.36
Accept image/webp,image/,/*;q=0.8
```

第一部分 请求行：

1. 包括三个字段（请求方法，URL 字段，HTTP 版本字段）

第二部分 请求头部：

1. 由关键字/值对组成，每行一对，关键字和值用英文冒号“：”分隔。
2. 请求头部通知服务器有关于客户端请求的信息，

| 键名              | 描述                                                                                                                             |
| ----------------- | -------------------------------------------------------------------------------------------------------------------------------- |
| Accept            | 客户端可识别的响应内容类型列表。用 \* 按范围将类型分组，用 \*/\* 指示可接受全部类型，用 type/\* 指示可接受 type 类型的所有子类型 |
| Accept-Language   | 客户端可接受的自然语言                                                                                                           |
| Accept-Encoding   | 客户端可接受的编码压缩格式                                                                                                       |
| Accept-Charset    | 可接受的应答字符集                                                                                                               |
| Connection        | 连接方式（close 或 keepalive）                                                                                                   |
| Cookie            | 存储于客户端扩展字段，向同一域名的服务器端发送属于该域的 cookie                                                                  |
| Host              | 请求的主机名，允许多个域名同处一个 IP 地址，即虚拟主机                                                                           |
| If-Modified-Since | 缓存时间                                                                                                                         |
| Referer           | 告诉服务器来自于哪里                                                                                                             |
| User-Agent        | 产生请求的浏览器类型                                                                                                             |

第三部分 空行：

1. 请求头部后面的空行是必须的。

第四部分 请求主体：

1. 其内容就是请求数据。
2. 使用 get 方法是实体为空，使用 post 方法时才使用该实体。

##### HTTP 响应报文

1.  一般情况下，服务器接收并处理客户端发过来的请求后会返回一个 HTTP 的响应消息。
2.  HTTP 响应由状态行、消息报头、空行和响应正文四个部分组成。

示例：

```
HTTP/1.1 200 OK，
Date: Sat，31 Dec 2005 23:59:59 GMT
Content-Type: text/html; charset=IS0-8859-1
Content-Length: 122

  <html>

  <head>
  <title>Wrox Homepage</title>
  </head>
  <body>
  <1-- body goes here ->
  </body>
  </html>
```

第一部分 状态行：

1. 由 HTTP 协议版本号， 状态码， 状态消息 三部分组成。
2. 示例中第一行为状态行，（HTTP/1.1）表明 HTTP 版本为 1.1 版本，状态码为 200，状态消息为（ok）。

第二部分 消息报头：

1. 示例中第二行和第三行为消息报头，
2. 用来说明客户端要使用的一些附加信息。

| 键名                | 描述                                                    |
| ------------------- | ------------------------------------------------------- |
| Cache-Control       | 服务端禁止客户端缓存页面数据                            |
| Connection          | 维护客户端和服务端的连接关系                            |
| Content-Disposition | 服务端要求客户端以下载文件的方式打开该文件              |
| Content-Encoding    | 服务端能够发送压缩编码类型                              |
| Content-Length      | 服务端发送的压缩数据的长度                              |
| Content-Language    | 服务端发送的语言类型                                    |
| Content-Type        | 服务端发送的类型及采用的编码方式                        |
| Date                | 服务端响应客户端的时间                                  |
| Expires             | 服务端禁止客户端缓存页面数据                            |
| Last-Modified       | 服务端对该资源最后修改的时间                            |
| Location            | 服务端需要客户端访问的页面路径                          |
| Refresh             | 服务端要求客户端 1 秒钟后，刷新，然后访问指定的页面路径 |
| Pragma              | 服务端禁止客户端缓存页面数据                            |
| Server              | 服务端的 Web 服务端名                                   |
| Set-Cookie          | 服务端发送到客户端的暂存数据                            |
| Transfer-Encoding   | 分块传递数据到客户端                                    |

第三部分 空行：

1. 消息报头后面的空行是必须的。

第四部分 响应正文：

1. 服务器返回给客户端的文本信息。
2. 示例中空行后面的 html 部分为响应正文。

##### HTTP 和 HTTPS

HTTP 协议：（HTTP-Hypertext transfer protocol)

1. 是一种详细规定了浏览器和万维网服务器之间互相通信规则的协议。

HTTPS 协议：（Hypertext Transfer Protocol over Secure Socket Layer）

1. 简单讲是 HTTP 的安全版，HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL。
2. https 协议需要到 ca（Certification Authority-认证机构）申请证书。
3. HTTPS 协议的主要作用：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。

HTTPS 工作流程：

1. 浏览器访问 https 的网站；
2. 服务器收到请求，准备证书（包含：算法、公钥、证书有效期）；
3. 服务器将证书发送到客户端；
4. 客户端收到证书，验证（很复杂的过程）成功后客户端生成一个随机数，用服务端的公钥对这个随机数加密，然后用 hash 算法生成签名做成证书。
5. 客户端把自己生成的证书发给服务端，因为只有服务端有私钥，所以只能服务端来解密，这样就保证了即使其他人截获也没用。
6. 服务端收到证书后，用私钥验签，并解密出来随机数。
7. 这个随机数就是后续网络传输数据使用的对称加密密钥，后面的通信就全部用这个随机数加密传输。

HTTPS 的缺点：

1. 通信两端都需要进行加密和解密，会消耗大量的 CPU、内存等资源，从而会增加服务器的负载。
2. 加密运算和多次握手降低了访问速度。
3. 在开发阶段，加大了页面调试难度。因为信息都被加密了，所以用代理工具时，需要先解密然后才能看到真实信息。
4. 用 HTTPS 访问的页面，页面内的外部资源都得用 HTTPS 请求，包括脚本中的 ajax 请求。

技术层面的区别：

1. HTTP 发起的请求建立到服务器指定默认端口是 80，HTTPS 是 443；
2. HTTP 无需证书，HTTPS 需要 CA 机构颁发的 SSL 证书；
3. HTTP 工作于应用层，HTTPS 工作于传输层。
4. http 信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。
5. http 的连接无状态（对同一个 url 请求没有上下文关系、每次的请求都是独立的、服务器中没有保存客户端的状态）。

#### FTP 协议

FTP 协议（File Transfer Protocol，文件传输协议）

- 中文简称为“文传协议”，它用于 Internet 上的控制文件的双向传输。

## 网络安全

### 网络攻击

#### XSS

Cross Site Script，跨站脚本攻击

1. 指将恶意脚本注入目标网页中，用户在访问该页面时，有可能造成信息泄露、用户行为被劫持、感染并传播蠕虫病毒等危害。

防范办法：

1. 为 Cookie 添加 HttpOnly 标记，使得客户端不能通过 JavaScript 读取 Cookie 信息。
2. 对提交到服务器中的信息做输入检查，例如白名单过滤、把字符编码成 HTML 实体等。
3. 对输出到页面中的信息做输出检查，检查方式和第二种类似。

#### CSRF

Cross Site Request Forgery，跨站点请求伪造

1. 攻击者伪装成正常用户，对服务器发起请求，让服务器执行某些操作。
2. 例如，用户正常登录某个网站，在未退出的情况下访问了攻击者事先准备好的页面，攻击者就能获取保存在 Cookie 中的登录信息，然后伪装成该用户，与服务器开始通信。

防范办法：

1. 让用户与网站进行交互才能完成请求，例如在表单中添加验证码。
2. 检查请求是否是来自合法的源，例如上一页的域名是否与当前相同。
3. 在每个请求中添加一个随机 Token 参数，可以在进入页面时生成，然后保存在 Session 中。
4. 服务器在接收到 Token 参数时进行校验，校验成功时才执行后面的操作。

## 网络服务

面向连接的网络服务：

1. 面向连接的网络服务又称为虚电路（Virtual Circuit）服务，它具有网络连接建立、数据传输和网络连接释放三个阶段。
2. 是按顺序传输可靠的报文分组方式，适用于指定对象、长报文、会话型传输要求。
3. 面向连接服务以电话系统为模式。
   1. 要和某个人通话，首先拿起电话，拨号码，通话，然后挂断。
   2. 同样在使用面向连接的服务时，用户首先要建立连接，使用连接，然后释放连接。
   3. 连接本质上像个管道，发送者在管道的一端放入物体，接收者在另一端按同样的次序取出物体；
4. 其特点是收发的数据不仅顺序一致，而且内容也相同。

无连接的网络服务：

1. 无连接网络服务的两实体之间的通信不需要事先建立好一个连接。
2. 无连接网络服务有 3 种类型：数据报（Datagram）、确认交付（Confirmed Delivery）、与请求回答（Request reply）。
3. 无连接服务以邮政系统为模式。
   1. 每个报文（信件）带有完整的目的地址，并且每一个报文都独立于其他报文，由系统选定的路线传递。
   2. 在正常情况下，当两个报文发往同一目的地时，先发的先到。
   3. 但也有可能先发的报文在途中延误了，后发的报文反而先收到。

### IP 地址（Internet Protocol）

1. IP 地址是互联网上主机或路由器的数字标识，用来唯一地标识该设备。

#### IPv4

InternetProtocol Version 4，互联网协议版本 4

1. 是一个被广泛使用的互联网协议，而 IPv6 是下一版本的互联网协议。
2. 主机号全为 0 表示本机地址，全为 1 表示广播地址。

分类：

1. A 类地址：

   - 结构为：0 + 7 位二进制组成的网络号 + 24 为二进制组成的主机号。
   - 即 1.0.0.0 / 8 ~ 126.0.0.0 / 8。

2. B 类地址：

- 结构为：10 + 14 位二进制组成的网络号 + 16 为二进制组成的主机号。
- 即 128.0.0.0 / 16 ~ 191.255.0.0 / 16。

3. C 类地址：

- 结构为：110 + 21 位二进制组成的网络号 + 8 为二进制组成的主机号。
- 即 192.0.0.0 / 24 ~ 223.255.255.0 / 24。

4. D 类地址：

   - 结构为：1110 + 28 位二进制组成的网络号。
   - 即 224.0.0.0 ~ 239.255.255.255。
   - 是专门保留的地址，并不指向特定的网络。
   - 目前被用在多点广播（Multicast）中。

5. E 类地址：

- 结构为：11110 + 27 位二进制组成的网络号。
- 即 240.0.0.0 ~ 255.255.255.255。
- 保留给将来使用。

私有地址：
A 类：10.0.0.0 ~10.255.255.255 即 10.0.0.0/8
B 类：172.16.0.0 ~172.31.255.255 即 172.16.0.0/12
C 类：192.168.0.0 ~192.168.255.255 即 192.168.0.0/16

#### IPV6

1. 随着互联网的迅速发展，IPv4 定义的有限地址空间将被耗尽，地址空间的不足必将妨碍互联网的进一步发展。
2. 为了扩大地址空间，拟通过 IPv6 重新定义地址空间。
3. IPv6 采用 128 位（合 16 个字节）地址长度，几乎可以不受限制地提供地址。
4. IPv6 不仅解决了地址短缺的问题，还考虑了在 IPv4 中存在的端到端 IP 连接、服务质量、安全性、多播、移动性及即插即用等问题。

### GET 和 POST 请求

区别：

1. 语义不同，GET 是获取数据，POST 是提交数据。
2. HTTP 规定 GET 比 POST 安全，因为 GET 只做读取，不会改变服务器中的数据。
   1. 但这只是规范，并不能保证请求方法的实现也是安全的。
3. GET 请求会把附加参数带在 URL 上，而 POST 请求会把提交数据放在报文内。
4. 在浏览器中，URL 长度会被限制，所以 GET 请求能传递的数据有限，但 HTTP 其实并没有对其做限制，都是浏览器在控制。
5. HTTP 规定 GET 是幂等的，而 POST 不是，所谓幂等是指多次请求返回相同的结果。
   1. 实际应用中，并不会这么严格，当 GET 获取动态数据时，每次的结果可能会有所不同。
6. GET 请求会保留在本地浏览器的历史记录中，而 POST 请求不会。
7. GET 请求可被收藏为书签，POST 请求不行。

## 网络设备

tcpdump ：

1. 是根据使用者的定义对网络上的数据包进行截获的包分析工具，工作在数据链路层。
2. tcpdump 是一种免费的网络分析工具，尤其是其提供了源代码，公开了接口，因此，它具备很强的可扩展性，对于网络维护和入侵防范都非常有用。

集线器：(Hub)

1. 属于数据通信系统中的基础设备，工作在物理层。

交换机：

1. 是一种基于 MAC 地址识别，能完成封装转发数据包功能的网络设备，工作在数据链路层。
2. 交换（switching）是按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术统称。

路由器：

1. 用于连接多个逻辑上分开的网络，工作在网络层。
