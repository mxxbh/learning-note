# 算法

## 排序算法

快速排序：

```js
function quickSort(array, start = 0, end = array.length - 1) {
  if (start >= end) return;

  var first = array[start],
    i = start,
    j = end;
  while (i < j) {
    while (first < array[j] && i < j) j--;
    if (i < j) {
      array[i] = array[j];
      i++;
    }
    while (first > array[i] && i < j) i++;
    if (i < j) {
      array[j] = array[i];
      j--;
    }
  }
  array[i] = first;
  quickSort(array, start, i - 1);
  quickSort(array, j + 1, end);
}
```

冒泡排序：

```js
function bubbleSort(array) {
  for (var i = 1; i < array.length; i++) {
    var key = 1;
    for (var j = 0; j < array.length - i; j++) {
      if (array[j] > array[j + 1]) {
        var x = array[j];
        array[j] = array[j + 1];
        array[j + 1] = x;
        key = 0;
      }
    }
    if (key == 1) break;
  }
}
```

桶排序：

- 空间换时间。

```js
function bucketSort(array) {
  var x = [];
  for (var i = 0; i < array.length; i++) {
    if (x[array[i]] == undefined) {
      x[array[i]] = 1;
    } else {
      x[array[i]]++;
    }
  }
  array.length = 0;
  x.forEach(function (a, i) {
    while (a != undefined && a > 0) {
      array.push(i);
      a--;
    }
  });
}
```

堆排序：

1. 对 n 个元素的序列进行堆排序，先将其建成堆，以根结点与第 n 个结点交换
2. 再调整前 n-1 个结点成为堆，再以根结点与第 n-1 个结点交换，重复上述操作，直到整个序列有序
3. 堆排序主要包括两个过程：一是构建堆；二是交换堆顶元素与最后一个元素的位置

拓扑排序：

- 用来判断图结构中有无回路的算法

1. 在求拓扑算法的过程中，最重要的是要维护一个入度为 0 的顶点的集合
2. 每次从这个集合中取出一个顶点，放入保存拓扑结构结果的列表中，然后从图中删除从这个顶点引出的所有边
3. 在删除这些边后，这个边的另外一个结点，如果入度变成 0，则加入到入度为 0 集合中
4. 依此类推，直到把所有顶点都遍历完成，就求出了拓扑结构
5. 如果在求解的过程中，存放入度为 0 的集合为空，但是此时图中还有没有遍历的边，则说明图中至少存在一个回路
